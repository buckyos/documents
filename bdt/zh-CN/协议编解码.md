# Package Decoder

并不是一个传统的，可以逐个byte放入的parser.而是必须一口气塞入整个Package的decoder

这样可以降低一些实现复杂度。分包的工作由上层Parser完成。

# TCP FirstPackage Parser

先读取

# TCP Parser

1. 如果是加密TCP Tunnel,那么每16个字节先解密，再丢给TCP Parser

2. 读取2字节长度，然后读取包内容

3. 将包内容塞给Package Decoder得到一个有效的Package

上述Decoder,Parser都是版本绑定的。在发布后实现时，要不断的创建类似 PackageDecoder_10，PackageDecoder_11这样的对象。已实现正确的向下兼容。

# Aes UnBox （udp）

1. 读取前64bit, 判断是否是合法的AesMixHash,得到AesKey

2. 把剩下的数据用AesKey解密，UnBox成功

# 加密传输方式

我们有2个等级（带身份验证的明文取消了）

1. 明文（不加密）

2. 全加密

从目前HTTPS大规模普及的角度考虑，系统默认使用最高的加密等级。

# 协议特征消除

从IP协议看到的BDT协议特征

1. ip1往ip2的 udp port发送了大量的unknown数据

如何定义大量：比平时多，ip2处于ip1不常通信的ip段

2. ip1往ip2发送的大量unknown数据包，有一个特点的特征（比如共同的数据头）

# Box 封包:

在通道上发送package时，需要根据通道的属性对package进行封包。封包逻辑本身是协议设计的一部分。Box的过程原则上不会影响Package原本包含的内容。

# Box Packages 包合并:

一个成功到达的P2P DataPackage是宝贵的。我们可以在这个宝贵的包中，通过Box Packages的方法多带一些包。这些包通过引用First Package的方法，可以省略自己与FirstPackage相同的字段，进而降低带宽占用和延迟。下面是一个典型的例子：

LN打算给RN投递一个DataGram（通过加密协议），不合并包的逻辑如下:  

```

LN->RN:EXCHANGE_KEY  

RN->LN:EXCHANGE_KEY_OK  

LN->RN:SYN_TUNNEL  

RN->LN:ACK_TUNNEL  

LN->RN:ACKACK_TUNNEL  

LN->RN:DATAGRAM  

RN:通知UserAPI 开始处理Datagram

RN->LN:DATAGRAM_RESP

```

经过包合并逻辑后，实际通信如下.  

```

LN->RN:EXCHANGE_KEY with SYN_TUNNEL with Datagram  

RN->LN:ACK_TUNNEL,通知UserAPI 开始处理Datagram  

LN->RN:ACKACK_TUNNEL  

RN->LN:DATAGRAM_RESP  

```

合并过程：  

EXCHANGE_KEY with SYN_TUNNEL with Datagram ，当Datagram不大时合并生效。

合并后的UDP包如下：  

```

<FirstPackage header>

<FirstPackage Body>

<totallen,cmdType>

<SecondPackage Body> // 这里会去掉FirstPackage Body中已经有的字段 为了达到这个目的，所有协议里body定义的字段名同名时意义都是相同的

<totallen,cmdType>

<ThirdPackage Body> // 这里会去掉FirstPackage, Body中已经有的字段

```