# 并发计算和吞吐率优化

个人产权环境下，所有的运算都在用户自己的个人服务器(`OOD`)上完成，这依然是一个中心化系统，对并发和吞吐量的处理策略跟`Web2`的中心服务器一样。但个人服务器的处理范围仅限于`自己`，`Web2`中心服务器的工作量事实上已经被分散到`Web3`中大量的个人服务器，并发和吞吐量的问题已经天然地被降低了。

共享产权是基于区块链技术来达成共识，从区块链的结构来看，区块链达成共识的过程都是串行的；这很难满足很多`Web2`应用场景里的高并发要求。

要提高共享产权信息的并发处理能力，我们可以考虑启用多条链同步工作，也就是把信息分散到多个`rpath`下。

考虑这样一个场景：一个`DAO`组织维护自己所有用户的信息。

其基于`RootState`的结构应该是如下这样：

```
/--users
    |--user1
    |   |--...
    |--user2
    |   |--...
    |--...
    |--userN
```

如果只用一个维护 users 根状态的链，那么每个用户信息的变更都应该串行执行。其实，大多数时候，用户之间通常并没有相关性，完全不必等`A`更新完了再更新`B`。

那么，我们不妨试着为每个用户都启用一条链，具体来说就是为每个用户信息的子路径启动一个共识链(`rpath`)来维护：

```
/users/user1
/users/user2
...
/users/userN
```

这里有一个小问题，用户列表也需要达成共识，其实每个用户的状态都达成共识，那么大部分时候这个组织维护的`rpath`列表就可以表达当前的用户列表。但它没有经过严格的共识链来专门维护它，有些异常情况可能会导致各节点记录的`rpath`列表不一致，也没有变更的历史记录。如果你的应用场景对这些问题很敏感的话，最好再设计一个`rpath`(/users/list)来维护用户列表，其内容和`rpath`列表的一致性问题就要根据场景具体问题具体分析了。

看到这里，对于`Web2`时代的服务端工程师来说，是不是有种似曾相识的感觉？对，它其实就类似于`Web2`里经常用到的`分表`，`分库`，只是形式变了。我没实际操作过`Web2`时代的大型数据库，就不班门弄斧了。
